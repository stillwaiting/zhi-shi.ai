{"version":3,"sources":["md/types.ts","AppContext.ts","body/BodyTextParagraphComponent.tsx","body/BodyOrderedListComponent.tsx","body/BodyTableComponent.tsx","body/BodyUnorderedListComponent.tsx","body/BodyQuestionComponent.tsx","body/BodyQuestionAnswerComponent.tsx","body/BodyComponent.tsx","TopicsTreeComponent.tsx","md/MarkdownBodyParser.ts","md/MarkdownParser.ts","NodeHeaderComponent.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["isMarkdownBodyChunk","obj","React","createContext","currentNodeTitle","currentNodeAnchor","currentSelectedText","onLinkClicked","link","toHtml","text","anchor","selectedText","htmlText","length","split","replaceAll","trim","join","map","chunk","idx","a1","a2","a3","a4","RegExp","replaceAllInserter","shim","data","context","useContext","AppContext","className","dangerouslySetInnerHTML","__html","onClick","e","targetLink","target","closest","attributes","value","startsWith","preventDefault","start","parseInt","items","item","itemIdx","body","rows","row","rowIdx","cells","cell","cellIdx","colSpan","rowSpan","content","DROPDOWN_REGEXP","shuffleArray","array","Math","random","i","j","floor","onSubmit","question","useState","match","selectedDropdownIndices","setSelectedDropdownIndices","isAnswered","setIsAnswered","splitQuestion","dropdownClassName","dropdownIdx","subSentence","subSentenceIdx","test","options","dropdownString","substr","slice","filter","disabled","onChange","newIndices","option","RED_CROSS","src","width","GREEN_TICK","renderAnswers","answers","dropdownIndices","dropdownIndex","setSubmittedDropdownIndices","indices","style","visibility","contentIdx","undefined","isMarkdownBodyChunkList","isOrdered","isMarkdownBodyChunkTable","isMarkdownBodyChunkQuestionAnswers","BodyQuestionAnswerComponent","renderNodes","nodes","onNodeClicked","node","nodeIdx","href","title","children","useEffect","timeout","setTimeout","selectedNodes","document","getElementsByClassName","oldScrollY","window","scrollY","scrollIntoView","scrollTo","left","scrollX","top","clearTimeout","isBeginningOfTable","line","findEndOfTable","lines","fromLineIdx","currLine","parseRowSpan","parseColSpan","skipSpans","parseTable","lineAfterTable","rowTexts","parsedTable","lineIdx","trimmedLine","push","cellText","parseBody","str","splitIdx","isBeginningOfParagraph","isBeginningOfList","isBeginningOfQuestionAnswers","findEndOfParagraph","currentLine","parseParagraph","lineAfterIdx","parsedParagraph","isNumber","isOrderedList","isUnorderedList","calculateListPadding","calculateOrderedListPadding","calculateUnorderedListPadding","getPadding","getOrderedListStart","line1","sameListItem","line2","start1","start2","findEndOfList","startFromLineIdx","padding","joinAndRemovePadding","parseList","untilLineIdx","parsedList","nextItemLines","findEndOfQuestionAnswers","parseQuestionsAnswers","parsedQuestionAnswers","markdownRawBody","parsedBody","lineAfterParagraph","lineAfterList","readAllSharpsFromStart","s","sharps","pos","parseChunk","parentPath","path","Object","assign","indexOf","childrenStartAt","childrenStr","childrenSharps","childChunks","shift","newNode","childrenByTitleIndex","reduce","index","childNode","mdString","separator","chunks","onTitleClicked","data-testid","pathItem","encodeTitle","encodeURI","findNodeWithTitle","maybeFoundInChildren","App","unsubmittedData","setUnsubmittedData","setNodes","topicsWidth","setTopicsWidth","externalNodeTitle","externalNodeLine","setExternalNodeLine","externalSelectedText","setExternalSelectedText","history","useHistory","location","useLocation","nodePath","parseNodePath","pathname","console","log","interval","setInterval","externalText","parse","clearInterval","currentNode","Provider","titleAndMaybeAnchor","currentNodePath","buildNodePath","externalGotoEditor","copy","currentTarget","String","placeholder","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.6555edd6.chunk.js","sourcesContent":["export interface MarkdownBodyChunk {\n}\nexport const isMarkdownBodyChunk = (obj: any): obj is MarkdownBodyChunk => {\n    return typeof obj === 'object';\n}\nexport interface MarkdownBodyChunkTextParagraph extends MarkdownBodyChunk {\n    text: string;\n}\nexport const isMarkdownBodyChunkTextParagraph = (obj: any): obj is MarkdownBodyChunkTextParagraph => {\n    const castObj = isMarkdownBodyChunk(obj) ? obj : null;\n    return !!castObj && obj.text !== undefined;\n}\n\nexport interface MarkdownBodyChunkList extends MarkdownBodyChunk {\n    start: string,\n    isOrdered: boolean,\n    items: Array<MarkdownBody>;\n}\nexport const isMarkdownBodyChunkList = (obj: any): obj is MarkdownBodyChunkList => {\n    const castObj = isMarkdownBodyChunk(obj) ? obj : null;\n    return !!castObj && obj.items !== undefined && obj.start !== undefined;\n}\n\nexport interface MarkdownTableCell {\n    rowSpan: number;\n    colSpan: number;\n    content: MarkdownBody;\n}\n\nexport interface MarkdownTableRow {\n    cells: Array<MarkdownTableCell>;\n}\n\nexport interface MarkdownBodyChunkTable extends MarkdownBodyChunk {\n    rows: Array<MarkdownTableRow>\n}\nexport const isMarkdownBodyChunkTable = (obj: any): obj is MarkdownBodyChunkTable => {\n    const castObj = isMarkdownBodyChunk(obj) ? obj : null;\n    return !!castObj && obj.rows !== undefined;\n}\n\nexport interface MarkdownBodyChunkQuestionAnswers extends MarkdownBodyChunk {\n    question: MarkdownBodyChunkTextParagraph,\n    answers: Array<MarkdownBodyChunkTextParagraph>\n}\nexport const isMarkdownBodyChunkQuestionAnswers = (obj: any): obj is MarkdownBodyChunkQuestionAnswers => {\n    const castObj = isMarkdownBodyChunk(obj) ? obj : null;\n    return !!castObj && obj.question !== undefined;\n}\n\n\nexport interface MarkdownBody {\n    content: Array<MarkdownBodyChunk>;\n}\n\nexport interface MarkdownNode {\n    title: string;\n    body: MarkdownBody;\n    path: Array<string>;\n\n    children: Array<MarkdownNode>;\n    childrenByTitleIndex:  { [key: string]: number };\n}","import React, { useState, useEffect } from 'react';\n\nexport type AppContext = {\n    currentNodeTitle: string,\n    currentNodeAnchor: string,\n    currentSelectedText: string,\n    onLinkClicked: (link: string) => void,\n};\n\nexport default React.createContext<AppContext>({\n    currentNodeTitle: '',\n    currentNodeAnchor: '',\n    currentSelectedText: '',\n    onLinkClicked: (link) => {}\n});","import { getNodeText } from '@testing-library/dom';\nimport React, { useState, useEffect, useContext } from 'react';\nimport './BodyTextParagraphComponent.scss';\n\nimport { isMarkdownBodyChunkTextParagraph, MarkdownBody, MarkdownBodyChunkTextParagraph, MarkdownNode } from '../md/types';\n\nimport AppContext  from '../AppContext';\n\n// @ts-ignore\nimport replaceAllInserter from 'string.prototype.replaceall';\nreplaceAllInserter.shim();\n\ntype BodyTextParagraphComponent = {\n    data: MarkdownBodyChunkTextParagraph\n};\n\n// Being pragmatic and decided not to parse it completely\nfunction toHtml(text: string, anchor: string, selectedText: string): string {\n    let htmlText = text;\n\n    if (selectedText.length > 0) {\n        htmlText = htmlText.split(selectedText.replaceAll(\"\\n\", \" \").trim()).join(\n            '<span class=\"selected\">' + selectedText + '</span>'\n        );\n    }\n    \n    htmlText = htmlText.split(\"**\").map((chunk, idx) => {\n        if (idx %2 == 1) {\n            return \"<b>\" + chunk + \"</b>\";\n        }\n        return chunk;\n    }).join('');\n\n    htmlText = htmlText.split(\"__\").map((chunk, idx) => {\n        if (idx %2 == 1) {\n            return \"<b>\" + chunk + \"</b>\";\n        }\n        return chunk;\n    }).join('');\n\n    htmlText = htmlText.split(\"_\").map((chunk, idx) => {\n        if (idx %2 == 1) {\n            return \"<i>\" + chunk + \"</i>\";\n        }\n        return chunk;\n    }).join('');\n\n    htmlText = htmlText.split(\"*\").map((chunk, idx) => {\n        if (idx %2 == 1) {\n            return \"<i>\" + chunk + \"</i>\";\n        }\n        return chunk;\n    }).join('');\n\n\n    htmlText = htmlText.replaceAll(/\\[(.*?)\\]\\((.*?)\\)/g, (a1, a2, a3, a4) => {\n        return '<a href=\\'' + a3.split('#').join('|') + '\\'>' + a2 + '</a>'\n    });\n\n    htmlText = htmlText.replaceAll(\n        // [#highlightedArea]blah[/] ====> <span class=\"highlight active\">blah</span>(<a href='#highlightedArea'>highlightedArea</a>)\n        new RegExp('\\\\[#' + anchor + '\\\\](.*?)\\\\[\\\\/\\\\]', 'g'), \n        '<span class=\"highlight active\">$1</span>(<a href=\\'|' + anchor + '\\'>' + anchor + '</a>)');\n    \n    htmlText = htmlText.replaceAll(\n        // [#foo]blah[/] ====> <span class=\"highlight highlight-foo\">blah</span>(<a href='#foo'>foo</a>)\n        /\\[#(.*?)\\](.*?)\\[\\/\\]/g, \n        '<span class=\"highlight highlight-$1\">$2</span>(<a href=\\'|$1\\'>$1</a>)'\n    );\n\n    return htmlText;\n}\n\nexport default ( { data }: BodyTextParagraphComponent ) => {\n    const context = useContext(AppContext);\n    return <p \n        className='BodyTextParagraphComponent' \n        dangerouslySetInnerHTML = {{__html: toHtml(data.text, context.currentNodeAnchor, context.currentSelectedText)}} \n        onClick={(e: React.MouseEvent<HTMLElement>) => {\n            const targetLink = (e.target as HTMLElement).closest('a');\n            if(!targetLink) return;\n            const href = targetLink.attributes[0].value;\n            if (!href.startsWith('#')) {\n                e.preventDefault();\n                context.onLinkClicked(targetLink.attributes[0].value); \n            }\n        }}\n    />;\n}\n\n\n\n","import { getNodeText } from '@testing-library/dom';\nimport React, { useState } from 'react';\nimport './BodyOrderedListComponent.scss';\nimport BodyComponent from './BodyComponent';\n\nimport { isMarkdownBodyChunkTextParagraph, MarkdownBody, MarkdownBodyChunkList, MarkdownBodyChunkTextParagraph, MarkdownNode } from '../md/types';\n\ntype BodyOrderedListComponent = {\n    data: MarkdownBodyChunkList\n};\n\nexport default ( { data }: BodyOrderedListComponent ) => {\n    return <ol start={parseInt(data.start)}>\n        {data.items.map((item, itemIdx) => \n            <li key={`li${itemIdx}`}><BodyComponent body={item} /></li>\n        )}\n    </ol>;\n}\n\n\n\n","import { getNodeText } from '@testing-library/dom';\nimport React, { useState } from 'react';\nimport './BodyTableComponent.scss';\nimport BodyComponent from './BodyComponent';\n\nimport { isMarkdownBodyChunkTextParagraph, MarkdownBody, MarkdownBodyChunkList, MarkdownBodyChunkTable, MarkdownBodyChunkTextParagraph, MarkdownNode } from '../md/types';\n\ntype BodyTableComponent = {\n    data: MarkdownBodyChunkTable\n};\n\nexport default ( { data }: BodyTableComponent ) => {\n    return <table className='BodyTableComponent'><tbody>\n        {data.rows.map((row, rowIdx) => \n            <tr key={`tr${rowIdx}`}>\n                {row.cells.map((cell, cellIdx) => \n                    <td key={`td${cellIdx}`} colSpan={cell.colSpan} rowSpan={cell.rowSpan}><BodyComponent \n                            body={cell.content} \n                    /></td>\n                )}\n            </tr>\n        )}\n    </tbody></table>;\n}\n\n\n\n","import { getNodeText } from '@testing-library/dom';\nimport React, { useState } from 'react';\nimport './BodyUnorderedListComponent.scss';\nimport BodyComponent from './BodyComponent';\n\nimport { isMarkdownBodyChunkTextParagraph, MarkdownBody, MarkdownBodyChunkList, MarkdownBodyChunkTextParagraph, MarkdownNode } from '../md/types';\n\ntype BodyUnorderedListComponent = {\n    data: MarkdownBodyChunkList\n};\n\nexport default ( { data }: BodyUnorderedListComponent ) => {\n    return <ul>\n        {data.items.map((item, itemIdx) => \n            <li key={`li${itemIdx}`}><BodyComponent body={item} /></li>\n        )}\n    </ul>;\n}\n\n\n\n","import React, { useState } from 'react';\nimport './BodyQuestionComponent.scss';\n\n// Searches for \"(blah|foo)\" dropdown representative strings\nconst DROPDOWN_REGEXP = /(\\(.+?\\|.*?\\))/g;\n\nconst parseDropdownString = (dropdownString: string) => \n    dropdownString.substr(1, dropdownString.length - 2).split('|')\n\nconst countDropdowns = (splitSentence: Array<string>) => \n    splitSentence.filter(subSentence => subSentence.match(DROPDOWN_REGEXP)).length;\n\ntype BodyQuestionComponentProps = {\n    onSubmit: (indices: Array<number>) => void, \n    question: string\n}\n\nfunction shuffleArray(array: Array<any>) {\n    if (Math.random() === 0) {\n        return array; // tests\n    }\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n}\n\nexport default ({ onSubmit, question }: BodyQuestionComponentProps) => {\n    const [selectedDropdownIndices, setSelectedDropdownIndices] = useState<Array<number>>(\n        (question.match(DROPDOWN_REGEXP) || []).map(question => Math.floor(Math.random() * question.split('|').length))\n    );\n    const [isAnswered, setIsAnswered] = useState<boolean>(false)\n\n    // Each item is either an arbitrary string or a \"dropdown\" string like \"(blah|foo)\"\n    const splitQuestion = question.split(DROPDOWN_REGEXP) || [];\n\n    const dropdownClassName = (dropdownIdx: number): string => {\n        if (isAnswered) {\n            if (selectedDropdownIndices[dropdownIdx] == 0) {\n                return 'success';\n            } else {\n                return 'error';\n            }\n        }\n        return '';\n    }\n\n    return (\n        <div className=\"BodyQuestionComponent\">\n            <div>\n                {splitQuestion.map((subSentence, subSentenceIdx) => {\n                    if (DROPDOWN_REGEXP.test(subSentence)) {\n                        const options = parseDropdownString(subSentence);\n                        const dropdownIdx = countDropdowns(splitQuestion.slice(0, subSentenceIdx));\n                        return [\n                            isAnswered ? <span key={`index${subSentenceIdx}`}>({dropdownIdx + 1})</span> : null,\n                            <span key={subSentenceIdx}>\n                                <select\n                                    className={dropdownClassName(dropdownIdx)}\n                                    disabled={isAnswered}\n                                    value={selectedDropdownIndices[dropdownIdx]}\n                                    onChange={e => {\n                                        const newIndices = [...selectedDropdownIndices];\n                                        newIndices[dropdownIdx] = parseInt(e.target.value);\n                                        setSelectedDropdownIndices(newIndices);\n                                    }}\n                                >\n                                {shuffleArray(options.map((option, idx) => (\n                                    <option key={idx} value={idx}>\n                                        {option}\n                                    </option>\n                                )))}\n                                </select>\n                            </span>\n                        ];\n                    } else {\n                        return <span key={subSentenceIdx}>{subSentence}</span>;\n                    }\n                })}\n            </div>\n            {isAnswered \n                ? null \n                :  <button className=\"button\" onClick={() => {\n                        setIsAnswered(true);\n            \n                        onSubmit(selectedDropdownIndices);\n                    }}>Submit</button>\n            }\n        </div>\n    );\n};\n","import React, { useState } from 'react'\nimport { MarkdownBodyChunkQuestionAnswers, MarkdownBodyChunkTextParagraph } from '../md/types'\nimport BodyTextParagraphComponent from './BodyTextParagraphComponent'\n\nimport BodyQuestionComponent from './BodyQuestionComponent'\n\ntype SentenceWithAnswers = {\n    data: MarkdownBodyChunkQuestionAnswers\n}\n\nconst RED_CROSS = <img className=\"error\" src='https://images2.imgbox.com/29/91/c4KeBiML_o.png' width='32' />\nconst GREEN_TICK = <img className=\"success\" src='https://images2.imgbox.com/7e/a3/Aiizr6oe_o.png' width='32' />\n\nfunction renderAnswers(answers: Array<MarkdownBodyChunkTextParagraph>, dropdownIndices: number[])  {\n    return <table><tbody>{dropdownIndices.map((dropdownIndex, idx) => {\n        if (answers[idx]) {\n            return <tr key={\"answer_\" + idx} className=\"answer\">\n                <td>({idx+1})</td>\n                <td>{dropdownIndex == 0 ? GREEN_TICK : RED_CROSS}</td>\n                <td><BodyTextParagraphComponent data={answers[idx]} /></td>\n            </tr>\n        } else {\n            return <span>Error, no answer</span>;\n        }\n    })}</tbody></table>;\n}\n\nexport default ( {data}: SentenceWithAnswers) => {\n    const [dropdownIndices, setSubmittedDropdownIndices] = useState<Array<number>>([])\n\n    return <div>\n        <div><BodyQuestionComponent question={data.question.text} onSubmit={(indices) => setSubmittedDropdownIndices(indices)} /></div>\n        {dropdownIndices.length > 0 ? renderAnswers(data.answers, dropdownIndices) : null}\n        <div style={{visibility: 'hidden'}}>\n            {RED_CROSS}\n            {GREEN_TICK}\n        </div>\n    </div>\n}\n","import { getNodeText } from '@testing-library/dom';\nimport React, { useState } from 'react';\nimport './BodyComponent.scss';\n\nimport { isMarkdownBodyChunkList, isMarkdownBodyChunkQuestionAnswers, isMarkdownBodyChunkTable, isMarkdownBodyChunkTextParagraph, MarkdownBody, MarkdownNode } from '../md/types';\nimport BodyTextParagraphComponent from './BodyTextParagraphComponent';\nimport BodyOrderedListComponent from './BodyOrderedListComponent';\nimport BodyTableComponent from './BodyTableComponent';\nimport BodyUnorderedListComponent from './BodyUnorderedListComponent';\nimport BodyQuestionAnswerComponent from './BodyQuestionAnswerComponent';\n\ntype BodyComponent = {\n    body: MarkdownBody\n};\n\nexport default ( { body }: BodyComponent ) => {\n    return <div className='BodyComponent'>\n        {body.content.map((chunk, contentIdx) => {\n            if (isMarkdownBodyChunkTextParagraph(chunk)) {\n                return <BodyTextParagraphComponent data = {chunk} key={`content${contentIdx}`} />\n            } else if (isMarkdownBodyChunkList(chunk)) {\n                if (chunk.isOrdered) {\n                    return <BodyOrderedListComponent data = {chunk} key={`content${contentIdx}`} />\n                } else {\n                    return <BodyUnorderedListComponent data = {chunk} key={`content${contentIdx}`} />\n                }\n            } else if (isMarkdownBodyChunkTable(chunk)) {\n                return <BodyTableComponent data={chunk} key={`content${contentIdx}`} />\n            } else if (isMarkdownBodyChunkQuestionAnswers(chunk)) {\n                return <BodyQuestionAnswerComponent data={chunk} key={`content${contentIdx}`} />\n            }\n        })}\n    </div>;\n}\n\n\n\n","import { getNodeText } from '@testing-library/dom';\nimport React, { useState, useEffect, useContext } from 'react';\nimport AppContext from './AppContext';\n\nimport { MarkdownNode } from './md/types';\nimport './TopicsTreeComponent.scss';\n\ntype TopicsTreeComponent = {\n    nodes: MarkdownNode[],\n    onNodeClicked: (node: MarkdownNode) => any\n}\n\nconst renderNodes = (nodes: MarkdownNode[], currentNodeTitle: string, onNodeClicked: (node: MarkdownNode) => any) => {\n    if (nodes.length == 0) {\n        return null;\n    }\n    return <ul>\n        {nodes.map((node, nodeIdx) => {\n            return <li key={`node${nodeIdx}`}>\n                <a href='#' onClick={(e) => {\n                    e.preventDefault();\n                    onNodeClicked(node);\n                }}\n                \n                className={(node.title === currentNodeTitle) ? \"selectedNode\" : \"plainNode\"}\n                \n                >{node.title}</a> <br />\n                {renderNodes(node.children, currentNodeTitle, onNodeClicked)}\n            </li>;\n        })}\n    </ul>;\n}\n\nexport default ({ nodes, onNodeClicked }: TopicsTreeComponent ) => {\n\n    const context = useContext(AppContext);\n\n    useEffect(() => {\n        const timeout = setTimeout(()=> {\n            const selectedNodes = document.getElementsByClassName('selectedNode');\n            if (selectedNodes.length > 0) {\n                const oldScrollY = window.scrollY;\n                selectedNodes[0].scrollIntoView();\n                window.scrollTo({\n                    left: window.scrollX,\n                    top: oldScrollY\n                });\n            }\n        }, 0);\n\n        return () => {\n            clearTimeout(timeout);\n        }\n    }, [context.currentNodeTitle]);\n\n    return <div className=\"TopicsTreeComponent\">\n        {renderNodes(nodes, context.currentNodeTitle, onNodeClicked)}\n    </div>;\n}","import { MarkdownBody, MarkdownBodyChunkList, MarkdownBodyChunkQuestionAnswers, MarkdownBodyChunkTable, MarkdownBodyChunkTextParagraph } from \"./types\"\n\nfunction isBeginningOfTable(line: string) {\n    return (line.trim().length > 0 && line.trim()[0] === '|');\n}\n\nfunction findEndOfTable(lines: Array<string>, fromLineIdx: number) {\n    let currLine = fromLineIdx;\n    do {\n        currLine ++;\n    } while (currLine < lines.length && (lines[currLine].trim().startsWith('|') || lines[currLine].trim().startsWith('-')));\n    return currLine;\n}\n\nfunction parseRowSpan(line: string): number {\n    if (line.startsWith(\"cols=\") || line.startsWith(\"rows=\")) {\n        const split = line.split(\"rows=\", 2);\n        return parseInt(split[1]);\n    }\n    return 1;\n}\n\nfunction parseColSpan(line: string): number {\n    if (line.startsWith(\"cols=\") || line.startsWith(\"rows=\")) {\n        const split = line.split(\"cols=\", 2);\n        return parseInt(split[1]);\n    }\n    return 1;\n}\n\nfunction skipSpans(line: string): string {\n    if (line.startsWith(\"cols=\") || line.startsWith(\"rows=\")) {\n        const split = line.split(\"\\n\", 2);\n        if (split.length > 1) {\n            return split[1];\n        }\n    }\n    return line;\n}\n\nfunction parseTable(lines: Array<string>, currLine: number, lineAfterTable: number) {\n    let rowTexts: Array<string> = [];\n    const parsedTable: MarkdownBodyChunkTable = {\n        rows: []\n    };\n    for (let lineIdx = currLine; lineIdx < lineAfterTable; lineIdx++) {\n        const trimmedLine = lines[lineIdx].trim();\n        if (trimmedLine.startsWith('|-') || trimmedLine.startsWith('| --') || trimmedLine.startsWith('-')) {\n            parsedTable.rows.push({\n                cells: rowTexts.map(cellText => ({\n                    rowSpan: parseRowSpan(cellText),\n                    colSpan: parseColSpan(cellText),\n                    content: parseBody(skipSpans(cellText))\n                }))\n            });\n            rowTexts = [];\n        } else {\n            let split = trimmedLine.split('|');\n            split = split.slice(1);\n            if (rowTexts.length == 0) {\n                rowTexts = split.map(str => str.trim());\n            } else {\n                for (let splitIdx = 0; splitIdx < split.length; splitIdx++) {\n                    if (splitIdx < rowTexts.length) {\n                        rowTexts[splitIdx] += '\\n' + split[splitIdx].trim();\n                    } else {\n                        rowTexts.push(split[splitIdx].trim());\n                    }\n                }\n            }\n        }\n    }\n    if (rowTexts.length > 0) {\n        parsedTable.rows.push({\n            cells: rowTexts.map(cellText => ({\n                rowSpan: parseRowSpan(cellText),\n                colSpan: parseColSpan(cellText),\n                content: parseBody(skipSpans(cellText))\n            }))\n        });\n    }\n    return parsedTable;\n}\n\nfunction isBeginningOfParagraph(line: string) {\n    return (line.trim().length > 0 && !isBeginningOfList(line) && !isBeginningOfTable(line)) && !isBeginningOfQuestionAnswers(line);\n}\n\nfunction findEndOfParagraph(lines: Array<string>, fromLineIdx: number) {\n    let currentLine = fromLineIdx;\n    do {\n        currentLine += 1;\n    } while (currentLine < lines.length && isBeginningOfParagraph(lines[currentLine]));\n    return currentLine;\n}\n\nfunction parseParagraph(lines: Array<string>, fromLineIdx: number, lineAfterIdx: number): MarkdownBodyChunkTextParagraph {\n    const parsedParagraph: MarkdownBodyChunkTextParagraph = {\n        text: ''\n    }\n\n    for (let currLine = fromLineIdx; currLine < lineAfterIdx; currLine ++) {\n        if (parsedParagraph.text.length == 0) {\n            parsedParagraph.text = lines[currLine].trim();\n        } else {\n            parsedParagraph.text += ' ' + lines[currLine].trim();\n        }\n    }\n    return parsedParagraph;\n}\n\nfunction isNumber(str: string) {\n    return str === ('' + parseInt(str))\n}\n\nfunction isOrderedList(line: string): boolean {\n    const trimmedLine = line.trim();\n\n    const split = trimmedLine.split('. ');\n    if (split.length == 1) {\n        return false;\n    }\n    if (split[0].length == 1) {\n        return true;\n    }\n    if (isNumber(split[0])) {\n        return true;\n    }\n    return false;\n}\n\nfunction isUnorderedList(line: string) {\n    const trimmedLine = line.trim();\n    return trimmedLine.startsWith('- ');\n}\n\nfunction isBeginningOfList(line: string) {\n    return isOrderedList(line) || isUnorderedList(line);\n}\n\nfunction calculateOrderedListPadding(line: string): number {\n    return line.split('. ', 2)[0].length + 2;\n}\n\nfunction calculateUnorderedListPadding(line: string): number {\n    return line.split('- ', 2)[0].length + 2;\n}\n\nfunction calculateListPadding(line: string): number {\n    if (isOrderedList(line)) {\n        return calculateOrderedListPadding(line);\n    }\n    return calculateUnorderedListPadding(line);\n}\n\nfunction getPadding(line: string): number {\n    for (let lineIdx = 0; lineIdx < line.length; lineIdx++) {\n        if (line[lineIdx] !== ' ') {\n            return lineIdx;\n        }\n    }\n    return 0;\n}\n\nfunction getOrderedListStart(line1: string): string {\n    return line1.trim().split('. ')[0];\n}\n\nfunction sameListItem(line1: string, line2: string) {\n    if (getPadding(line1) != getPadding(line2)) {\n        return false;\n    }\n    if (isUnorderedList(line1) && isUnorderedList(line2)) {\n        return line1.trim()[0] == line2.trim()[0];\n    }\n    if (isOrderedList(line1) && isOrderedList(line2)) {\n        const start1 = getOrderedListStart(line1);\n        const start2 = getOrderedListStart(line2);\n\n        if (start1.length == start2.length) {\n            return true;\n        }\n\n        if (isNumber(start1) && isNumber(start2)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction findEndOfList(lines: Array<string>, startFromLineIdx: number): number {\n    const padding = calculateListPadding(lines[startFromLineIdx]);\n    let currentLine = startFromLineIdx;\n    do {\n        currentLine ++;\n    } while (currentLine < lines.length && (getPadding(lines[currentLine]) >= padding || sameListItem(lines[startFromLineIdx], lines[currentLine])));\n    return currentLine;\n}\n\nfunction joinAndRemovePadding(lines: Array<string>, padding: number) {\n    return lines.map(line => line.substr(padding)).join(\"\\n\");\n}\n\nfunction parseList(lines: Array<string>, startFromLineIdx: number, untilLineIdx: number): MarkdownBodyChunkList {\n    const isOrdered = isOrderedList(lines[startFromLineIdx]);\n    const padding = calculateListPadding(lines[startFromLineIdx]);\n    const parsedList: MarkdownBodyChunkList = {\n        isOrdered: isOrdered,\n        start: isOrdered ? getOrderedListStart(lines[startFromLineIdx]) : lines[startFromLineIdx].trim()[0],\n        items: []\n    };\n    let nextItemLines: Array<string> = [];\n    for (let lineIdx = startFromLineIdx; lineIdx < untilLineIdx; lineIdx ++ ) {\n        if (sameListItem(lines[startFromLineIdx], lines[lineIdx]) && (nextItemLines.length > 0)) {\n            parsedList.items.push(\n                parseBody(joinAndRemovePadding(\n                    nextItemLines, padding\n                ))\n            );\n            nextItemLines = [];\n        }\n        nextItemLines.push(lines[lineIdx]);\n    }\n    if (nextItemLines.length > 0) {\n        parsedList.items.push(\n            parseBody(joinAndRemovePadding(\n                nextItemLines, padding\n            ))\n        );\n        nextItemLines = [];\n    }\n    return parsedList;\n}\n\nfunction isBeginningOfQuestionAnswers(line: string) {\n    return line.trim().startsWith('?');\n}\n\nfunction findEndOfQuestionAnswers(lines: Array<string>, fromLineIdx: number) {\n    let currLine = fromLineIdx;\n    do {\n        currLine ++;\n    } while (currLine < lines.length && (lines[currLine].trim().startsWith('?') || lines[currLine].trim().startsWith('!')));\n    return currLine;\n}\n\nfunction parseQuestionsAnswers(lines: Array<string>, startFromLineIdx: number, untilLineIdx: number): MarkdownBodyChunkQuestionAnswers {\n    const parsedQuestionAnswers: MarkdownBodyChunkQuestionAnswers = {\n        question: {\n            text: ''\n        },\n        answers: []\n    };\n    let nextItemLines: Array<string> = [];\n    for (let lineIdx = startFromLineIdx; lineIdx < untilLineIdx; lineIdx ++ ) {\n        if (lineIdx == startFromLineIdx) {\n            parsedQuestionAnswers.question = parseParagraph([lines[lineIdx].trim().substr(1)], 0, 1);\n            continue;\n        }\n\n        parsedQuestionAnswers.answers.push(parseParagraph([lines[lineIdx].trim().substr(1)], 0, 1));\n    }\n    return parsedQuestionAnswers;\n}\n\nfunction parseBody(markdownRawBody: string): MarkdownBody {\n    const parsedBody: MarkdownBody = {\n        content: []\n    };\n\n    const lines = markdownRawBody.trim().split(\"\\n\");\n\n    let currLine = 0;\n    while (currLine < lines.length) {\n        if (isBeginningOfParagraph(lines[currLine])) {\n            const lineAfterParagraph = findEndOfParagraph(lines, currLine);\n            parsedBody.content.push(parseParagraph(lines, currLine, lineAfterParagraph));\n            currLine = lineAfterParagraph;\n            continue;\n        }\n\n        if (isBeginningOfList(lines[currLine])) {\n            const lineAfterList = findEndOfList(lines, currLine);\n            parsedBody.content.push(parseList(lines, currLine, lineAfterList));\n            currLine = lineAfterList;\n            continue;\n        }\n\n        if (isBeginningOfTable(lines[currLine])) {\n            const lineAfterTable = findEndOfTable(lines, currLine);\n            parsedBody.content.push(parseTable(lines, currLine, lineAfterTable));\n            currLine = lineAfterTable;\n            continue;\n        }\n\n        if (isBeginningOfQuestionAnswers(lines[currLine])) {\n            const lineAfterTable = findEndOfQuestionAnswers(lines, currLine);\n            parsedBody.content.push(parseQuestionsAnswers(lines, currLine, lineAfterTable));\n            currLine = lineAfterTable;\n            continue;\n        }\n\n        currLine += 1;\n    }\n    return parsedBody;\n}\n\nexport default parseBody;","import { MarkdownNode } from './types';\nimport parseBody from './MarkdownBodyParser';\n\nfunction readAllSharpsFromStart(s: string) {\n    let sharps = \"\";\n    let pos = 0;\n    while (pos < s.length && s[pos] == '#') {\n        sharps += '#';\n        pos ++;\n    }\n    return sharps;\n}\n\nfunction parseChunk(chunk: string, parentPath: Array<String>): MarkdownNode {\n    const split = (chunk.trim() + \"\\n\").split(\"\\n\");\n    const title = split[0];\n    const body = split.slice(1).join(\"\\n\").trim();\n\n    const path = Object.assign([], parentPath);\n    path.push(title.trim());\n\n    if (body.indexOf(\"\\n#\") >= 0 || body.startsWith(\"#\")) {\n        const childrenStartAt = body.indexOf(\"\\n#\");\n        const childrenStr = body.substr(childrenStartAt+1);\n        const childrenSharps = readAllSharpsFromStart(childrenStr);\n        const childChunks = (\"\\n\" + childrenStr).split(\"\\n\" + childrenSharps + \" \");\n        childChunks.shift();\n        const newNode = {\n            title: title.trim(),\n            path: path,\n            body: parseBody(body.substr(0, childrenStartAt).trim()),\n            children: childChunks.map(chunk => parseChunk(chunk, path)),\n            childrenByTitleIndex: {},\n        };\n        newNode.childrenByTitleIndex = newNode.children.reduce((index: { [key:string]: number }, childNode, idx) => {\n            index[childNode.title] = idx;\n            return index;\n        }, {});\n        return newNode;\n    } else {\n        return {\n            title: title.trim(),\n            path: path,\n            body: parseBody(body.trim()),\n            children: [],\n            childrenByTitleIndex: {}\n        };\n    }\n}\n\n\nexport default (mdString: string, parentPath: Array<String>): Array<MarkdownNode> => {\n    mdString = mdString.trim();\n\n    if (mdString.length == 0) {\n        return [];\n    }\n\n    if (mdString[0] != '#') {\n        throw \"must start with #\"\n    }\n\n    const separator = readAllSharpsFromStart(mdString);\n\n    const chunks = (\"\\n\" + mdString).split(\"\\n\" + separator + \" \");\n    chunks.shift();\n\n    return chunks.map(chunk => parseChunk(chunk, parentPath))\n}","import { getNodeText } from '@testing-library/dom';\nimport React, { useState } from 'react';\n\nimport { MarkdownBody, MarkdownNode } from './md/types';\n\nimport './NodeHeaderComponent.scss';\n\ntype NodeHeaderComponent = {\n    path: Array<string>,\n    onTitleClicked: (title: string) => void\n};\n\nexport default ( { path, onTitleClicked }: NodeHeaderComponent ) => {\n    return <div className='NodeHeaderComponent' data-testid='NodeHeaderComponent'>\n        {path.map((pathItem, index) => {\n            return <span key={`pathItem${index}`}> \n                    <span className='separator'>/</span>\n                <a href='#' onClick={(e) => {\n                        e.preventDefault();\n                        onTitleClicked(pathItem);\n                }}>{pathItem}</a>\n            </span>;\n        })}\n    </div>;\n}\n","import React, { useState, useEffect } from 'react';\nimport logo from './logo.svg';\nimport './App.scss';\nimport BodyComponent from './body/BodyComponent';\nimport TopicsTreeComponent from './TopicsTreeComponent';\nimport parse from './md/MarkdownParser';\nimport { MarkdownNode } from './md/types';\nimport NodeHeaderComponent from './NodeHeaderComponent';\nimport { BrowserRouter as Router, Route, Link, useHistory, useLocation } from \"react-router-dom\";\nimport AppContext from './AppContext';\nimport copy from 'copy-to-clipboard';\n\n // @ts-ignore\nimport replaceAllInserter from 'string.prototype.replaceall';\nreplaceAllInserter.shim();\n\nfunction encodeTitle(title: string) {\n  return encodeURI(title).replaceAll('/', '%2F');\n}\n\nfunction buildNodePath(titleAndMaybeAnchor: string, currentNodePath: string[]): string {\n  if (titleAndMaybeAnchor.startsWith(\"..\") && titleAndMaybeAnchor.indexOf('|') >= 0 && currentNodePath.length > 1) {\n    const split = titleAndMaybeAnchor.split('|');\n    return encodeTitle(currentNodePath[currentNodePath.length - 2]) + '|' + encodeTitle(split[1]);\n  } \n\n  if (titleAndMaybeAnchor.startsWith('|')) {\n    return encodeTitle(currentNodePath[currentNodePath.length - 1]) + '|' + encodeTitle(titleAndMaybeAnchor.substr(1));\n  }\n\n  if (titleAndMaybeAnchor === \"..\") {\n    return encodeTitle(currentNodePath[currentNodePath.length - 2]);\n  } \n\n  if (titleAndMaybeAnchor.indexOf('|') >= 0) {\n    const split = titleAndMaybeAnchor.split('|');\n    return encodeTitle(split[0]) + '|' + encodeTitle(split[1]);\n  }\n\n  return encodeTitle(titleAndMaybeAnchor);\n}\n\nfunction findNodeWithTitle(nodes: MarkdownNode[], title: string): MarkdownNode | null {\n  for (let nodeIdx = 0; nodeIdx < nodes.length; nodeIdx++) {\n    if (nodes[nodeIdx].title === title) {\n      return nodes[nodeIdx];\n    }\n    const maybeFoundInChildren = findNodeWithTitle(nodes[nodeIdx].children, title);\n    if (maybeFoundInChildren) {\n      return maybeFoundInChildren;\n    }\n  }\n  return null;\n}\n\ndeclare global {\n  interface Window { \n    externalText: string | undefined; \n    externalNodeTitle: string | undefined;\n    externalNodeLine: number | undefined;\n    externalSelectedText: string | undefined;\n    externalGotoEditor: ((nodeTitle: string) => void) | undefined;\n  }\n}\n\nfunction parseNodePath(nodePath: string) {\n  let title = nodePath.substr(1).replaceAll('%2F', '/');\n  let anchor = '';\n\n  if (title.indexOf('|') >= 0) {\n    const split = title.split('|');\n    title = split[0];\n    anchor = split[1];\n  }\n  return [title, anchor];\n}\n\nfunction App() {\n  const [unsubmittedData, setUnsubmittedData] = useState<string>(\"\");\n  const [nodes, setNodes] = useState<MarkdownNode[]>([]);\n  const [topicsWidth, setTopicsWidth] = useState<number>(300);\n  const [externalNodeTitle, setExternalNodeTitle] = useState<string>(\"\");\n  const [externalNodeLine, setExternalNodeLine] = useState<number>(0);\n  const [externalSelectedText, setExternalSelectedText] = useState<string>(\"\");\n\n  const history = useHistory();\n  const location = useLocation();\n\n  const [currentNodeTitle, currentNodeAnchor] = parseNodePath(location.pathname);\n\n  console.log(location.pathname, currentNodeTitle, currentNodeAnchor);\n\n  useEffect(() => {\n      const interval = setInterval(() => {\n        if (window.externalText && window.externalText !== unsubmittedData) {\n          setNodes(parse(window.externalText, []));\n          setUnsubmittedData(window.externalText);\n        }\n\n        if (window.externalNodeLine && window.externalNodeTitle && window.externalNodeLine !== externalNodeLine) {\n          const node = findNodeWithTitle(nodes, window.externalNodeTitle);\n          if (node) {\n            history.push(encodeTitle(node.title));\n            setExternalNodeLine(window.externalNodeLine);\n          }\n        }\n\n        if (window.externalSelectedText !== undefined && window.externalSelectedText !== externalSelectedText) {\n            setExternalSelectedText(window.externalSelectedText);\n        }\n\n      }, 500);\n\n      return () => {\n        clearInterval(interval);\n      }\n      \n    },\n  [nodes, externalNodeLine, externalNodeTitle, externalSelectedText, unsubmittedData]);\n\n  const onDataChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setUnsubmittedData(e.currentTarget.value);\n  }\n\n  const onSubmitClicked = () => {\n    setNodes(parse(unsubmittedData, []));\n  }\n\n  const onIncreseWidthClick = () => {\n    setTopicsWidth(topicsWidth + 50);\n  }\n\n  const onDecreaseWidthClick = () => {\n    setTopicsWidth(topicsWidth - 50);\n  }\n\n  const currentNode = findNodeWithTitle(nodes, currentNodeTitle);\n\n  return (\n    <AppContext.Provider value={{\n      currentNodeTitle: currentNodeTitle,\n      currentNodeAnchor: currentNodeAnchor,\n      currentSelectedText: externalSelectedText,\n      onLinkClicked: (link) => {\n        history.push(buildNodePath(link, currentNode ? currentNode.path : []));\n      }\n    }}>\n      <div className=\"App\">\n        <div className=\"topics\" style={{width: topicsWidth + 'px' }} data-testid='menu-container'>\n\n          <a href='#' onClick={(e) => {\n            e.preventDefault();\n            onIncreseWidthClick();\n          }} data-testid='plus'>+ width</a> |\n\n          <a href='#' onClick={(e) => {\n            e.preventDefault();\n            onDecreaseWidthClick();\n          }} data-testid='minus'>- width</a> <br />\n\n          <TopicsTreeComponent nodes={nodes} onNodeClicked={(node) => {\n            history.push(encodeTitle(node.title));\n          }} />\n        </div>\n\n        <div className=\"content\">\n            {currentNode \n              ? <div>\n                    <NodeHeaderComponent path={currentNode.path} onTitleClicked={(title) => history.push(encodeTitle(title)) } />\n                    {window.externalGotoEditor && currentNode ? \n                      <div>\n                          <a href='#' onClick={(e) => { \n                              e.preventDefault();\n                              window.externalGotoEditor!(currentNode.title);\n                          }}>goto</a>\n                      </div> : null\n                    }\n\n                    {currentNodeTitle \n                      ? <div>\n                          <a href='#' onClick={(e) => {\n                            e.preventDefault();\n                            copy(currentNodeTitle + (currentNodeAnchor ? '#' + currentNodeAnchor : '') );\n                          }}>copy link</a>\n                        </div>\n                      : null}\n                    \n                    <BodyComponent body={currentNode.body} />\n                </div>\n              : 'Not selected'\n            }\n        </div>\n        <hr />\n        <textarea data-testid='textarea' onChange={onDataChange} value={String(unsubmittedData)} placeholder=\"Paste your data\"></textarea>\n        <hr />\n        <button data-testid='submit' onClick={onSubmitClicked}>Submit</button>\n      </div>\n    </AppContext.Provider>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { BrowserRouter as Router, Route, Switch, Link, useHistory } from \"react-router-dom\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Router>\n      <Switch>\n          <Route >\n            <App />\n          </Route>\n        </Switch>\n    </Router>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}